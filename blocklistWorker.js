let usernameBlocklistSet = new Set(); // Exact matches for blocking usernames extracted from breached dataset
let stuffingBlocklistSet = new Set(); // Exact matches for stuffing attacks - passwords extracted from breached dataset
let tweakingBlocklistSet = new Set(); // Password variants for tweaking detection - generated by AI-model

function charFrequencyVector(str) {
    let charMap = {};
    for (let char of str) {
        charMap[char] = (charMap[char] || 0) + 1;
    }
    return charMap;
}

function cosineSimilarity(str1, str2) {
    let vec1 = charFrequencyVector(str1);
    let vec2 = charFrequencyVector(str2);
    let uniqueChars = new Set([...Object.keys(vec1), ...Object.keys(vec2)]);
    let dotProduct = 0, mag1 = 0, mag2 = 0;
    
    uniqueChars.forEach(char => {
        let v1 = vec1[char] || 0;
        let v2 = vec2[char] || 0;
        dotProduct += v1 * v2;
        mag1 += v1 * v1;
        mag2 += v2 * v2;
    });
    
    return dotProduct / (Math.sqrt(mag1) * Math.sqrt(mag2));
}

function damerauLevenshteinDistance(s1, s2) {
    let len1 = s1.length;
    let len2 = s2.length;
    let d = Array.from({ length: len1 + 1 }, () => Array(len2 + 1).fill(0));
    
    for (let i = 0; i <= len1; i++) d[i][0] = i;
    for (let j = 0; j <= len2; j++) d[0][j] = j;
    
    for (let i = 1; i <= len1; i++) {
        for (let j = 1; j <= len2; j++) {
            let cost = s1[i - 1] === s2[j - 1] ? 0 : 1;
            d[i][j] = Math.min(
                d[i - 1][j] + 1,     // Deletion
                d[i][j - 1] + 1,     // Insertion
                d[i - 1][j - 1] + cost  // Substitution
            );
            
            // Transposition (Restricted)
            if (i > 1 && j > 1 && s1[i - 1] === s2[j - 2] && s1[i - 2] === s2[j - 1]) {
                d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
            }
        }
    }
    return d[len1][len2];
}

function damerauLevenshteinSimilarity(str1, str2) {
    let distance = damerauLevenshteinDistance(str1, str2);
    let maxLen = Math.max(str1.length, str2.length);
    return 1 - (distance / maxLen);
}

function hybridSimilarity(str1, str2, w1 = 0.5, w2 = 0.5) {
    let freqSimilarity = cosineSimilarity(str1, str2);
    let orderSimilarity = damerauLevenshteinSimilarity(str1, str2);
    return (w1 * freqSimilarity) + (w2 * orderSimilarity);
}

self.onmessage = function (e) {
    const { action, password, threshold, stuffingBlocklist, tweakingBlocklist } = e.data;

    if (action === "load") {
        stuffingBlocklistSet = new Set(stuffingBlocklist);
        tweakingBlocklistSet = new Set(tweakingBlocklist);
        self.postMessage({ status: "loaded", stuffingSize: stuffingBlocklistSet.size, tweakingSize: tweakingBlocklistSet.size });
    } 
    else if (action === "check") {
        if (stuffingBlocklistSet.has(password)) {
            self.postMessage({ exists: true, similar: false });
            return;
        }

        if (tweakingBlocklistSet.has(password)) {
            console.log(`Password Found in Tweaking Blocklist: ${password}`);
            self.postMessage({ exists: true, similar: false });
            return;
        }

        let maxSimilarity = 0;
        let closestMatch = null;

        for (let blockPassword of stuffingBlocklistSet) {
            let score = hybridSimilarity(password, blockPassword);
            if (score > maxSimilarity) {
                maxSimilarity = score;
                closestMatch = blockPassword;
            }
            if (maxSimilarity >= threshold) {
                break;
            }
        }

        for (let blockPassword of tweakingBlocklistSet) {
            let score = hybridSimilarity(password, blockPassword);
            if (score > maxSimilarity) {
                maxSimilarity = score;
                closestMatch = blockPassword;
            }
            if (maxSimilarity >= threshold) {
                break;
            }
        }

        self.postMessage({ exists: false, similar: maxSimilarity >= threshold, closestMatch, similarity: maxSimilarity });
    }
};
